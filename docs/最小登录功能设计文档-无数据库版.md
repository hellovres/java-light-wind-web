# 最小登录功能设计文档（无数据库版）

## 1. 设计目标

设计一个极简的用户登录功能，核心特性：
- 使用JWT进行无状态认证
- 支持用户名+密码登录
- 支持Token刷新机制
- **无需数据库，使用内存模拟用户数据**
- 代码简洁，易于理解和维护

---

## 2. 技术栈

| 组件 | 技术选型 | 版本 |
|------|---------|------|
| 后端框架 | Spring Boot | 3.2 |
| 安全框架 | Spring Security | 6 |
| 认证方式 | JWT | - |
| 密码加密 | BCrypt | - |
| 用户存储 | 内存（Map） | - |

---

## 3. 模拟用户数据设计

### 3.1 用户数据存储

使用 `ConcurrentHashMap` 存储模拟用户数据：

```java
@Component
public class InMemoryUserStore {

    private final Map<String, User> users = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        // 初始化测试用户
        users.put("admin", new User(
            1L,
            "admin",
            "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy" // 密码: admin123
        ));

        users.put("user", new User(
            2L,
            "user",
            "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy" // 密码: admin123
        ));
    }

    public User findByUsername(String username) {
        return users.get(username);
    }

    public boolean existsByUsername(String username) {
        return users.containsKey(username);
    }

    public User save(User user) {
        users.put(user.getUsername(), user);
        return user;
    }
}
```

### 3.2 用户实体

```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Long id;
    private String username;
    private String password;  // BCrypt加密后的密码
}
```

### 3.3 刷新令牌存储

```java
@Component
public class InMemoryRefreshTokenStore {

    private final Map<String, RefreshTokenInfo> tokens = new ConcurrentHashMap<>();

    public void save(String token, Long userId) {
        tokens.put(token, new RefreshTokenInfo(
            token,
            userId,
            Instant.now().plusSeconds(604800)  // 7天后过期
        ));
    }

    public boolean existsByTokenAndUserId(String token, Long userId) {
        RefreshTokenInfo info = tokens.get(token);
        return info != null && info.getUserId().equals(userId) &&
               !info.isExpired();
    }

    public void deleteByUserId(Long userId) {
        tokens.entrySet().removeIf(entry ->
            entry.getValue().getUserId().equals(userId)
        );
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    private static class RefreshTokenInfo {
        private String token;
        private Long userId;
        private Instant expiredTime;

        public boolean isExpired() {
            return Instant.now().isAfter(expiredTime);
        }
    }
}
```

### 3.4 初始测试账号

| 用户名 | 密码 | 说明 |
|--------|------|------|
| admin | admin123 | 管理员账号 |
| user | admin123 | 普通用户账号 |

---

## 4. API 设计

### 4.1 统一响应格式

```json
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": 1707200000000
}
```

### 4.2 接口列表

#### 4.2.1 用户注册
```
POST /api/auth/register
Content-Type: application/json

Request:
{
  "username": "newuser",
  "password": "password123"
}

Response 200:
{
  "code": 200,
  "message": "注册成功",
  "data": {
    "id": 3,
    "username": "newuser"
  }
}

Response 400:
{
  "code": 400,
  "message": "用户名已存在"
}
```

#### 4.2.2 用户登录
```
POST /api/auth/login
Content-Type: application/json

Request:
{
  "username": "admin",
  "password": "admin123"
}

Response 200:
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 7200
  }
}

Response 401:
{
  "code": 401,
  "message": "用户名或密码错误"
}
```

#### 4.2.3 获取当前用户信息
```
GET /api/auth/me
Authorization: Bearer {token}

Response 200:
{
  "code": 200,
  "message": "success",
  "data": {
    "id": 1,
    "username": "admin"
  }
}

Response 401:
{
  "code": 401,
  "message": "Token无效或已过期"
}
```

#### 4.2.4 刷新Token
```
POST /api/auth/refresh
Content-Type: application/json

Request:
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

Response 200:
{
  "code": 200,
  "message": "刷新成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 7200
  }
}

Response 401:
{
  "code": 401,
  "message": "RefreshToken无效或已过期"
}
```

#### 4.2.5 登出
```
POST /api/auth/logout
Authorization: Bearer {token}

Response 200:
{
  "code": 200,
  "message": "登出成功"
}
```

---

## 5. JWT Token 设计

### 5.1 Token 结构

```json
// Access Token (有效期: 2小时)
{
  "sub": "1",                    // 用户ID
  "username": "admin",          // 用户名
  "iat": 1707200000,            // 签发时间
  "exp": 1707207200             // 过期时间
}

// Refresh Token (有效期: 7天)
{
  "sub": "1",                    // 用户ID
  "username": "admin",          // 用户名
  "iat": 1707200000,            // 签发时间
  "exp": 1707804800             // 过期时间
}
```

### 5.2 Token 配置

| 配置项 | 值 | 说明 |
|--------|-----|------|
| 签名算法 | HS256 | 对称加密 |
| Access Token 有效期 | 2小时 (7200秒) | 短期访问令牌 |
| Refresh Token 有效期 | 7天 (604800秒) | 用于刷新访问令牌 |
| 密钥 | 至少256位 | 生产环境需从环境变量读取 |

---

## 6. 核心流程

### 6.1 注册流程
```
1. 接收用户名和密码
2. 检查内存中用户名是否已存在
3. 密码使用 BCrypt 加密
4. 生成用户ID
5. 保存用户到内存Map
6. 返回成功信息
```

### 6.2 登录流程
```
1. 接收用户名和密码
2. 从内存Map中查询用户
3. 验证密码（BCrypt）
4. 验证成功：
   - 生成 Access Token (2小时)
   - 生成 Refresh Token (7天)
   - 保存 Refresh Token 到内存
   - 返回双Token
5. 验证失败：返回401错误
```

### 6.3 获取用户信息流程
```
1. 从请求头获取 Bearer Token
2. 解析和验证 Token
3. 从 Token 中获取用户信息
4. 从内存Map中查询用户
5. 返回用户数据
```

### 6.4 刷新Token流程
```
1. 接收 Refresh Token
2. 验证 Token 有效性（签名、过期时间）
3. 从内存中验证 Refresh Token 是否存在
4. 从 Token 中获取用户ID
5. 生成新的 Access Token
6. 返回新的 Access Token
```

### 6.5 登出流程
```
1. 从请求头获取 Bearer Token
2. 从 Token 中获取用户ID
3. 删除内存中的 Refresh Token
4. 返回成功信息
5. 客户端丢弃 Token
```

---

## 7. 安全设计

### 7.1 密码安全
- 使用 BCrypt 算法加密（强度因子：10）
- 内存只存储加密后的密码
- 永不返回密码

### 7.2 Token 安全
- Access Token 短期有效（2小时）
- Refresh Token 长期有效但可撤销
- Token 存储在客户端（localStorage 或 cookie）
- 生产环境使用 HTTPS 传输

### 7.3 输入验证
- 用户名：3-50个字符，字母数字下划线
- 密码：至少6个字符
- 使用 `@Validated` 注解验证请求参数

---

## 8. 项目结构

```
src/main/java/com/lightwind/web/
├── controller/
│   └── AuthController.java           # 认证相关接口
├── service/
│   ├── AuthService.java              # 认证服务接口
│   └── AuthServiceImpl.java          # 认证服务实现
├── store/                            # 内存存储
│   ├── InMemoryUserStore.java        # 用户数据存储
│   └── InMemoryRefreshTokenStore.java # 刷新令牌存储
├── model/
│   ├── User.java                     # 用户实体
│   ├── dto/
│   │   ├── LoginRequest.java         # 登录请求
│   │   ├── RegisterRequest.java      # 注册请求
│   │   └── LoginResponse.java        # 登录响应
│   └── vo/
│       └── UserInfoVO.java           # 用户信息VO
├── security/
│   ├── JwtAuthenticationFilter.java  # JWT认证过滤器
│   ├── SecurityConfig.java           # Spring Security配置
│   ├── CustomUserDetailsService.java # 用户详情服务
│   └── JwtUtil.java                  # JWT工具类
├── config/
│   ├── SecurityConfig.java           # 安全配置
│   └── WebMvcConfig.java             # Web配置
└── exception/
    ├── GlobalExceptionHandler.java   # 全局异常处理
    ├── AuthenticationException.java  # 认证异常
    └── UserAlreadyExistsException.java # 用户已存在异常

src/main/resources/
├── application.yml                   # 主配置文件
└── application-prod.yml              # 生产环境配置
```

---

## 9. Maven 依赖

```xml
<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Boot Security -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>

    <!-- JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.12.3</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.12.3</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.12.3</version>
        <scope>runtime</scope>
    </dependency>

    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!-- Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## 10. 配置文件

### 10.1 application.yml
```yaml
spring:
  application:
    name: lightwind-auth

server:
  port: 8080

jwt:
  secret: my-super-secret-key-at-least-256-bits-long-for-security
  access-token-expiration: 7200      # 2小时
  refresh-token-expiration: 604800   # 7天

logging:
  level:
    com.lightwind.web: DEBUG
```

### 10.2 application-prod.yml
```yaml
jwt:
  secret: ${JWT_SECRET}

logging:
  level:
    com.lightwind.web: INFO
```

---

## 11. 异常处理

### 11.1 异常类型

| 异常类 | HTTP状态码 | 说明 |
|--------|-----------|------|
| AuthenticationException | 401 | 认证失败、Token无效 |
| UserNotFoundException | 404 | 用户不存在 |
| UserAlreadyExistsException | 409 | 用户已存在 |
| InvalidTokenException | 401 | Token无效或过期 |

### 11.2 全局异常处理器

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<Map<String, Object>> handleAuthenticationException(
            AuthenticationException ex) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body(Map.of(
                    "code", 401,
                    "message", ex.getMessage(),
                    "timestamp", System.currentTimeMillis()
                ));
    }

    @ExceptionHandler(UserAlreadyExistsException.class)
    public ResponseEntity<Map<String, Object>> handleUserAlreadyExistsException(
            UserAlreadyExistsException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .body(Map.of(
                    "code", 409,
                    "message", ex.getMessage(),
                    "timestamp", System.currentTimeMillis()
                ));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleException(Exception ex) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of(
                    "code", 500,
                    "message", "服务器内部错误",
                    "timestamp", System.currentTimeMillis()
                ));
    }
}
```

---

## 12. 实施步骤

### Step 1: 初始化项目
```bash
# 创建 Spring Boot 项目
mvn archetype:generate -DgroupId=com.lightwind.web \
    -DartifactId=java-light-wind-web \
    -DarchetypeArtifactId=maven-archetype-quickstart \
    -DinteractiveMode=false
```

### Step 2: 添加依赖
- 在 pom.xml 中添加所需依赖（见第9节）

### Step 3: 创建实体类
- User.java

### Step 4: 创建内存存储
- InMemoryUserStore.java
- InMemoryRefreshTokenStore.java

### Step 5: 实现 JWT 工具类
- JwtUtil.java（生成、解析、验证Token）

### Step 6: 实现 Service 层
- AuthServiceImpl.java（注册、登录、刷新Token、登出）

### Step 7: 配置 Spring Security
- SecurityConfig.java
- JwtAuthenticationFilter.java
- CustomUserDetailsService.java

### Step 8: 创建 Controller
- AuthController.java（暴露REST API）

### Step 9: 异常处理
- 自定义异常类
- GlobalExceptionHandler.java

### Step 10: 测试
- 单元测试
- API 测试（Postman/curl）

---

## 13. 测试用例

### 13.1 注册测试
```bash
curl -X POST http://localhost:8080/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username": "newuser", "password": "password123"}'
```

### 13.2 登录测试
```bash
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "admin123"}'
```

### 13.3 获取用户信息测试
```bash
curl -X GET http://localhost:8080/api/auth/me \
  -H "Authorization: Bearer {token}"
```

### 13.4 刷新Token测试
```bash
curl -X POST http://localhost:8080/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "{refreshToken}"}'
```

### 13.5 登出测试
```bash
curl -X POST http://localhost:8080/api/auth/logout \
  -H "Authorization: Bearer {token}"
```

---

## 14. 核心代码示例

### 14.1 InMemoryUserStore.java
```java
@Component
public class InMemoryUserStore {

    private final Map<String, User> users = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        // 初始化测试用户
        users.put("admin", User.builder()
                .id(1L)
                .username("admin")
                .password("$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy")
                .build());

        users.put("user", User.builder()
                .id(2L)
                .username("user")
                .password("$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy")
                .build());
    }

    public User findByUsername(String username) {
        return users.get(username);
    }

    public boolean existsByUsername(String username) {
        return users.containsKey(username);
    }

    public User save(User user) {
        users.put(user.getUsername(), user);
        return user;
    }

    public Long getNextId() {
        return users.values().stream()
                .mapToLong(User::getId)
                .max()
                .orElse(0L) + 1;
    }
}
```

### 14.2 InMemoryRefreshTokenStore.java
```java
@Component
public class InMemoryRefreshTokenStore {

    private final Map<String, RefreshTokenInfo> tokens = new ConcurrentHashMap<>();

    public void save(String token, Long userId) {
        tokens.put(token, new RefreshTokenInfo(
            token,
            userId,
            Instant.now().plusSeconds(604800)  // 7天后过期
        ));
    }

    public boolean existsByTokenAndUserId(String token, Long userId) {
        RefreshTokenInfo info = tokens.get(token);
        return info != null && info.getUserId().equals(userId) &&
               !info.isExpired();
    }

    public void deleteByUserId(Long userId) {
        tokens.entrySet().removeIf(entry ->
            entry.getValue().getUserId().equals(userId)
        );
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    private static class RefreshTokenInfo {
        private String token;
        private Long userId;
        private Instant expiredTime;

        public boolean isExpired() {
            return Instant.now().isAfter(expiredTime);
        }
    }
}
```

### 14.3 JwtUtil.java
```java
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.access-token-expiration}")
    private long accessTokenExpiration;

    @Value("${jwt.refresh-token-expiration}")
    private long refreshTokenExpiration;

    private Key getSigningKey() {
        return new SecretKeySpec(
            secret.getBytes(StandardCharsets.UTF_8),
            SignatureAlgorithm.HS256.getJcaName()
        );
    }

    public String generateAccessToken(String username, Long userId) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        return createToken(claims, username, accessTokenExpiration);
    }

    public String generateRefreshToken(String username, Long userId) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        return createToken(claims, username, refreshTokenExpiration);
    }

    private String createToken(Map<String, Object> claims, String subject, long expiration) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date())
                .expiration(new Date(System.currentTimeMillis() + expiration * 1000))
                .signWith(getSigningKey())
                .compact();
    }

    public String extractUsername(String token) {
        return extractClaims(token).getSubject();
    }

    public Long extractUserId(String token) {
        return extractClaims(token).get("userId", Long.class);
    }

    public boolean isTokenExpired(String token) {
        return extractClaims(token).getExpiration().before(new Date());
    }

    public boolean validateToken(String token, String username) {
        return extractUsername(token).equals(username) && !isTokenExpired(token);
    }

    private Claims extractClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
```

### 14.4 AuthServiceImpl.java
```java
@Service
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

    private final InMemoryUserStore userStore;
    private final InMemoryRefreshTokenStore refreshTokenStore;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;

    @Override
    public LoginResponse register(RegisterRequest request) {
        if (userStore.existsByUsername(request.getUsername())) {
            throw new UserAlreadyExistsException("用户名已存在");
        }

        User user = User.builder()
                .id(userStore.getNextId())
                .username(request.getUsername())
                .password(passwordEncoder.encode(request.getPassword()))
                .build();

        userStore.save(user);

        String accessToken = jwtUtil.generateAccessToken(user.getUsername(), user.getId());
        String refreshToken = jwtUtil.generateRefreshToken(user.getUsername(), user.getId());

        refreshTokenStore.save(refreshToken, user.getId());

        return LoginResponse.builder()
                .token(accessToken)
                .refreshToken(refreshToken)
                .expiresIn(7200)
                .build();
    }

    @Override
    public LoginResponse login(LoginRequest request) {
        User user = userStore.findByUsername(request.getUsername());

        if (user == null) {
            throw new AuthenticationException("用户名或密码错误");
        }

        if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
            throw new AuthenticationException("用户名或密码错误");
        }

        String accessToken = jwtUtil.generateAccessToken(user.getUsername(), user.getId());
        String refreshToken = jwtUtil.generateRefreshToken(user.getUsername(), user.getId());

        refreshTokenStore.save(refreshToken, user.getId());

        return LoginResponse.builder()
                .token(accessToken)
                .refreshToken(refreshToken)
                .expiresIn(7200)
                .build();
    }

    @Override
    public String refreshAccessToken(String refreshToken) {
        String username = jwtUtil.extractUsername(refreshToken);
        Long userId = jwtUtil.extractUserId(refreshToken);

        if (!refreshTokenStore.existsByTokenAndUserId(refreshToken, userId)) {
            throw new InvalidTokenException("RefreshToken无效");
        }

        return jwtUtil.generateAccessToken(username, userId);
    }

    @Override
    public void logout(String token) {
        String username = jwtUtil.extractUsername(token);
        User user = userStore.findByUsername(username);

        if (user == null) {
            throw new AuthenticationException("用户不存在");
        }

        refreshTokenStore.deleteByUserId(user.getId());
    }
}
```

---

## 15. 部署说明

### 15.1 本地运行
```bash
# 运行应用
mvn spring-boot:run

# 或打包后运行
mvn clean package
java -jar target/java-light-wind-web.jar
```

### 15.2 生产部署
```bash
# 运行
java -jar target/java-light-wind-web.jar \
    --spring.profiles.active=prod \
    --JWT_SECRET=your-secret-key-at-least-256-bits
```

---

## 16. 注意事项

### 16.1 内存存储限制
- 应用重启后所有数据丢失
- 不适合生产环境
- 仅用于开发、测试、演示

### 16.2 并发安全
- 使用 `ConcurrentHashMap` 保证线程安全
- 适用于单机部署
- 多实例部署会导致数据不一致

### 16.3 后续扩展
如需持久化存储，可以：
- 添加 Spring Data JPA + 数据库
- 替换 InMemoryUserStore 为 UserRepository
- 替换 InMemoryRefreshTokenStore 为 RefreshTokenRepository

---

## 附录

### A. 相关文档
- [Spring Security 官方文档](https://docs.spring.io/spring-security/reference/)
- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)
- [Spring Boot 官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/)

### B. 项目依赖版本
- Spring Boot: 3.2.0
- Spring Security: 6.2.0
- jjwt: 0.12.3
- Lombok: 1.18.30

### C. BCrypt密码生成
```java
// 生成 BCrypt 密码（用于初始化测试数据）
String encodedPassword = BCrypt.hashpw("admin123", BCrypt.gensalt(10));
// 输出: $2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
```
